
# https://protosupplies.com/product/capacitive-soil-moisture-sensor-module/
# - use nail varnish or similar to seal the edges of the pcb
# - VCC = 3.3V – 5.5V


substitutions:
  ip: 192.168.8.31
  name: banana


preferences:
  flash_write_interval: 30s

esphome:
  name: $name
  on_boot:
    then:
      - ds1307.read_time:
      - delay: 120s
      - if:
          condition:
            lambda: |-
                return (id(ntp).utcnow().hour == 24);
          then:
            - if:
                condition:
                    lambda: |-
                        return (id(ntp).utcnow().timestamp - id(last_pump_ts).state > 60*60*20) && (id(ntp).utcnow().hour > id(hour).state);
                then:
                    - number.set:
                        id: last_pump_ts
                        value: !lambda |-
                            return id(ntp).utcnow().timestamp;
                    - delay: 40s
                    - logger.log: "periodic action!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!..."
                    - switch.turn_on: periodic_pump1
                    - delay: 140s
                    - logger.log: "periodic action offfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff..."
                    - switch.turn_off: periodic_pump1
                    - deep_sleep.enter:
                        id: deep_sleep_1
                        #sleep_duration: !lambda |-
                        #  return 20*60*60
                        sleep_duration: 20h
                        #time_id: ntp
                else:
                    - deep_sleep.enter:
                        id: deep_sleep_1
                        sleep_duration: 1h
                        #time_id: ntp







esp32:
  board: denky32

wifi:
  networks:
  - ssid: !secret ssid
    password: !secret password
    manual_ip:
      static_ip: $ip
      gateway: 192.168.8.1
      subnet: 255.255.255.0
      dns1: 192.168.8.1
      dns2: 8.8.8.8
    
  ap:
    ssid: !secret fallback_ssid
    password: !secret fallback_password



api:
  password: ""
  reboot_timeout: 1h # 0s # The amount of time to wait before rebooting when no WiFi connection exists. Can be disabled by setting this to 0s, but note that the low level IP stack currently 
  
  
  
mqtt:
  broker: !secret mqtt_host
  port: !secret mqtt_port
  username: !secret mqtt_user
  password: !secret mqtt_password

  on_message:
    - topic: $name/ota_mode
      payload: 'ON'
      then:
        - logger.log: "deep_sleep.prevent..."
        - deep_sleep.prevent: deep_sleep_1
    - topic: $name/ota_mode
      payload: 'OFF'
      then:
        - logger.log: "deep_sleep.allow..."
        - deep_sleep.allow: deep_sleep_1
    - topic: $name/inc
      then:
        - logger.log: "inc..."
        - lambda: |-
            id(my_global_int) += 1;
    - topic: $name/now
      then:
        - logger.log: "now..."
        - lambda: |-
            id(my_global_int) = id(ntp).utcnow().timestamp;
        - number.set:
            id: num1
            value: !lambda |-
              return id(ntp).utcnow().timestamp;



ota:
  password: ""

    
logger:
  on_message:
    level: ERROR
    then:
      - mqtt.publish:
          topic: some/topic
          payload: !lambda |-
            return "Triggered on_message with level " + to_string(level) + ", tag " + tag + " and message " + message;



captive_portal:
    
web_server:
  port: 80
  ota: true




sensor:
  - platform: wifi_signal
    name: "Irrigation Wifi"
    update_interval: 60s
    
  - platform: adc
    pin: 35
    id: dryness
    name: "dryness"
    update_interval: 1s
    attenuation: 11db
    filters:
      - multiply: 10
  - platform: sun
    name: Sun Elevation
    type: elevation
  - platform: sun
    name: Sun Azimuth
    type: azimuth


  - platform: template
    name: "Template Sensor"
    lambda: |-
        return id(kyticky).action ;
    update_interval: 1s
      
light:
  - platform: status_led
    name: "status LED(pin2)"
    id: status
    pin: 2

switch:
#  - platform: gpio
#    pin: 2
#    id: status_led_pin2
#    name: "s2"
  - platform: gpio
    pin: 19
    id: s3
    name: "s3"
  - platform: gpio
    pin: 20
    id: periodic_pump1
    name: "periodic_pump1"
  - platform: restart
    id: manual_restart
    name: "Living Room Restart"
    #restore_mode: ALWAYS_OFF

    
    
climate:
  - platform: thermostat
    id: kyticky
    name: "kyticky"
    sensor: dryness
    min_cooling_off_time: 5s
    min_cooling_run_time: 2s
    max_cooling_run_time: 2s
    min_idle_time: 10s
    supplemental_cooling_action:

      - if:
            condition:
                - sun.is_above_horizon:
            then:
                - logger.log: Land is dry and Sun is above horizon!

                - light.turn_on: status
                - delay: 1s
                - light.turn_off: status


                - switch.turn_on: s3
                - delay: 1s
                - switch.turn_off: s3
            else:
                - logger.log: Land is dry and Sun is below horizon!
                

    supplemental_cooling_delta: 1
    cool_action:
      - logger.log: cool!
    idle_action:
      - light.turn_off: status
      - switch.turn_off: s3
    default_preset: Home
    preset:
      - name: Home
        mode: COOL
        default_target_temperature_high: 20 °C
    
    





sun:
  latitude: 50.0755°
  longitude: 14.4378°

  on_sunrise:
    - then:
        - logger.log: Good morning!
  on_sunset:
    - then:
        - logger.log: Good evening!




# display sun values in gui        
text_sensor:
  - platform: sun
    name: Next Sunrise
    type: sunrise
  - platform: sun
    name: Next Sunset
    type: sunset
  - platform: template
    name: "Time NTP"
    lambda: |-
      char str[30];
      if (!id(ntp).now().is_valid()) { return { "----" }; }
      time_t currTime = id(ntp).now().timestamp;
      strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S", localtime(&currTime));
      //strftime(str, sizeof(str), "%c", localtime(&currTime));
      return  { str };
    update_interval: 5s
  - platform: template
    name: "Time RTC"
    lambda: |-
      char str[30];
      time_t currTime = id(rtc).now().timestamp;
      strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S", localtime(&currTime));
      //strftime(str, sizeof(str), "%c", localtime(&currTime));
      return  { str };
    update_interval: 5s





        
time:  # https://esphome.io/components/time/ds1307.html#ds1307-config-example

  - platform: ds1307
    id: rtc
    update_interval: never

  - platform: homeassistant
    on_time_sync:
      then:
        - logger.log: "rtc.write_time..."
        - ds1307.write_time
        - logger.log: "Synchronized clock."

  - platform: sntp
    id: ntp
    #timezone: Europe/Prague
    on_time_sync:
      then:
        - logger.log: "rtc.write_time..."
        - ds1307.write_time
        - logger.log: "Synchronized clock."


deep_sleep:
#  run_duration: 10min
#  sleep_duration: 10min
  wakeup_pin: 13
  id: deep_sleep_1


i2c:
#  sda: 21
#  scl: 22
  scan: true
  id: bus_a







number:
  - platform: template
    id: num1
    name: "blbost"
    optimistic: true
    min_value: 0
    max_value: 3360287004
    step: 1

  - platform: template
    id: hour
    name: "pump hour"
    optimistic: true
    min_value: 0
    max_value: 24
    step: 1
    restore_value: true
    initial_value: 24
    
  - platform: template
    id: last_pump_ts
    name: "last_pump_ts"
    optimistic: true
    min_value: 0
    max_value: 3360287004
    step: 1
    restore_value: true
    initial_value: 0
    

globals:
  - id: my_global_int
    type: int
    restore_value: yes
    initial_value: '5'


